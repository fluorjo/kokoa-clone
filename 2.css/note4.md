1. css가 하는 일=html을 가리키는 일.  
이렇게 가리키는 걸 selector라고 한다.

2. css 속성에는 빈칸, 밑줄, 슬래쉬 사용 못함.  하이픈, 붙임표만 써야함.

3. css:Cascading Style Sheets.  Cascading이란 '위에서 아래로 흐르는', '상속 또는 종속하는'.  
=브라우저가 css를 읽을 때 위에 있는 코드부터 차례대로 읽는다.  

4. 그렇기 때문에 항상 '마지막'에 있는 명령어가 최종적으로 실행된다. 예를 들어 똑같은 h1태그에 대해 외부 css파일에서 먼저 색을 빨강이라고 했다가 html에서 나중에 파랑이라고 하면 최종 결과물은 파랑이 된다.  

반대로 css link 코드를 html의 style 부분보다 아래에 넣으면 css 파일의 내용이 적용된다.  

- ★★★따라서 코드를 일일이 다 수정할 필요 없이 뒤에 추가해주면 된다.

5. 속성이 겹치지 않으면 한 태그의 속성을 여러 번 나눠서 지정하는 것도 가능하다.  

예를 들어 h1{ color:red } 해놓고 다시 h1{font-size:40px}이라고 해도 다 적용된다.  

3.3  
- 옆에 다른 요소가 올 수 없는 것들을 block, 있는 것들을 inline(in the same line)이라고 한다.  

- block에 해당하는 것들, 예를 들어 div는 요소의 옆에 다른 요소가 올 수 없다. 무조건 아래로 나열된다.(header, main, section, paragraph 등도 그렇다?)  

- 반면 inline인 것들, 예를 들어 span,a,image는 옆에 올 수 있어서 옆으로 나열된다.

- 대부분의 box는 block이다.  

3.4.
- display 속성: block을 inline으로, 또 반대로도 가능하게 해주는 것.  

- block은 높이와 너비를 가질 수 있지만 inline은 그렇지 않다.  

- box(block?)의 큰 특징 3가지=margin, padding, border.

- 브라우저는 요소들에게 기본적으로 style의 속성을 제공한다. 예를 들어 요소 검사를 해보면 body에 user agent stylesheet{display:black; margin:8px}라고 돼있음.

- margin : box의 border의 바깥 공간.  
상하좌우 지정 안 하고, 값이 '하나'면 상하좌우 전부 다에 적용됨.  
20px 15px 이런 식으로 값이 '두 개'면 앞의 값은 상하, 뒤의 값은 좌우로 적용됨.  
값을 4개 주면 위 오른쪽 아래 왼쪽 순서임. 시계방향.  


- collapse margin: 두 경계가 하나인 걸로 취급되는 현상. 두 박스의 경계가 같을 때 일어남. 
그래서 하나의 마진을 수정하면  다른 거랑 합쳐서 수정됨.

3.6.  
- 마진은 박스의 경계로부터 바깥 공간.  
- 패딩은 박스의 경계로부터 안쪽 공간.

3.7.  

- 스타일에서 * 에다가 속성 입력하면 문서 전체에 적용하겠다는 의미.

- border는 inline과 block 모두에 적용 가능.  

- id 별로 속성을 부여할 때는 #을 이용한다. #아이디 {}  

3.8.  

- inline-block의 문제점  
    - 한 마디로 말해서 responsive design(반응형 디자인)을 지원하지 않는다.
    - 정체를 알 수 없는 공백이 생긴다...  
    - 정해진 형식이 없다. 예를 들어 요소 크기를 키우면 그 요소들 사이의 공백이 줄어드는데 그 이유를 알 수 없음...  
    - 그러다 보니 페이지 맨 왼쪽과 맨 오른쪽 공간의 여백 크기가 다르다던가 하는 문제가 생김. 언제 다음 줄로 요소가 넘어갈지도 모름. 심지어 컴퓨터 화면 크기에 따라 이게 다 다름. 
    - 일일이 수치 바꿔가며 맞춰야 했다... 이게 실제로 옛날에 한 방식...

3.10.  
- flexbox:박스를 아무 데나 둘 수 있다.  
- 규칙 1.자식 엘리먼트에는 아무 것도 적지 말아야 한다. 자식 엘리먼트들(예:div)을 움직이려면 부모 엘리먼트(body)에 지시해야 함.  
- 부모 엘리먼트를 flex container로 만들어야 한다. display:flex 라고.  
- justify-content를 하면 공간을 알아서 계산해서 배치를 해준다.  
- 규칙 2. main axis는 가로, cross axis는 세로로 적용된다. 전자는 justify-content, 후자는 align-items 같은 게 있다.  
- 다만 기본 값에서 align-items를 center로 놔도 아무 변화도 없을 것. body의 크기는 '박스의 크기 만큼' 크기 때문에 align-items 하기 전에도 이미 수직으로 중심이기 때문.  
변화가 있으려면 height 값을 지정해줘야 함.  
- stretch는 자식 엘리먼트를 늘리는 것. 근데 뒤에서 자식 엘리먼트에다 가로세로 높이를 지정해놨다면 안 먹힐 것.  

- flex-direction: main axis와 cross axis 설정 바꾸기.  

3.12.  

- position: 위치를 아주 조금 옮기고 싶을 때 사용.

-  position:fixed; ★★★layer를 부순다. &맨 위로 오게 한다.  
해주면 스크롤 계속 내려도 원래 위치에 계속 고정.  


- 주의:div 중 일부만 pix 시키고 싶으면 전체 div에는 fix 속성 안 줘야 됨. 위 아래 다 주면 겹쳐짐.  

3.13.  
- position static:레이아웃이 박슬르 처음 위치하는 곳에 두는 것.  

- position relative: 요쇼가 처음 위치한 곳을 기준으로 위치를 수정. top, bottom, left, right 지정 가능. 요소를 조금씩만 옮기고 싶을 때 사용.  

- ★★id 단위에 속성 부여할 때는 #, class 단위에는 . 을 씀.

- position:absolute:가장 가까운 'relative' 부모를 기준으로 이동시켜줌.  
바로 부모가 relative 아니면 위로 계속 올라감. (body까지?)  

3.14.  

- pseudo_selector:요소를 더 세부적으로 선택하게 해줌

- ★★★★★★★★★★★★★★★★★★★★★Live Server 사용할 때는 div:last-child 써도 적용이 안됨. live server가 자체적으로 Body 태그 안쪽 맨 아래에 보이지 않는 스크립트 태그 ( 또는 어떤 것 ) 을 만들기 때문에 더이상 div가 last-child가 아니게 되기 때문.  

- '>'는 자식을, '+'는 형제를 찾을 때 사용. '~'는 형제 관계에서 바로 뒤가 아닌 것도 찾을 수 있음. 

3.17.  
- active:클릭했을 때  
- hover:마우스 올려놨을 때  
- focus:키보드 탭 해서 버튼에 올려놨을 때. 혹은 마우스 클릭할 때랑 그 '다음'에 계속 남는 상태  

약간 focus가 active의 상위 개념이랄지 active를 포함하는 개념 같음. active 없어도 focus 있으면 클릭할 때 색깔 적용됨.  

그래서 셋 다 적용하려면 active가 focus 뒤로 와야 함.  

- focus-within: focused인 자식을 가진 부모 엘리먼트의 상태.  

3.19.변수 지정할 때는 --로 지정, 사용할 때는 var()로 사용.

